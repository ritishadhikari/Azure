Introduction to Continous Delivery:
    - Eight Principles of Continous delivery:
        - The process for releasing/deploying software must be
        repeatable and reliable
        - Automate Everything
        - If something is difficult or painful, do it more Often
        - Keep everything in source control
        - Done means released
        - Build quality in
        - Everybody has responsibility for the release process
        - Improve continously
    - To deploy more often, we need to consider:
        - Software Architecture as monoliths are hard to deploy
        - Testing Strategy (manual tests don't scale well) 
        - Organization as separated business and IT departments don't work smoothly
    - Continous Delivery is a practice and is being able to deliver 
    software on-demand
    - Deploying every code change to production is what is called Continous 
    deployment

    - Feedback loops or quality gates are required for :
        - A unit test to validate the code
        - An automated build to validate the sources
        - An automated test on a Test Environment
        - Some monitor on a server
        - Usage Instrumentation in the code
    
    - Companies wants to move forward towards Continous Delivery since:
        - They see the value
        - They hear their customers
        - Companies wish to deliver their products as fast as possible
        - Quality should be higher
        - The move to production should be faster
        - Technical Debt should be lower
    - Release:
        - It includes a snapshot of all the information required to carry out all 
        the tasks and actions in the release pipeline:
            - The stages or environments
            - The tasks for each one
            - The values of task parameters and variables
            - The release policies such as trigger, approvers and release queuing
            options
        - There can be multiple deployments of each release, even for one stage
        - When a release deployment fails for a stage, you can redeploy the same
        release to that stage
        - The release pipeline contains all the steps you walk through when you move 
        your artifact from one of the artifact sources through the stages or 
        environments
        - The release is an instance of the release pipeline
        - Release Pipeline is the blueprint through which releases are done

Create a Release pipeline:
    - Capabilities for Service Containers and Container Jobs can be run in YAML 
    pipelines only and not in classic build and classic release
    - The components that make up the release pipeline or process are used to create
    a release
    - Components in a release pipeline:
        - Artifacts:
            - Comes from various sources like build pipeline or source control
            - It is a deployable component of your application which can then be 
            deployed to one or more environments
            - Artifacts will be deployed to multiple environments
            - Most common way to get an artifact within the release pipeline is 
            to use a build artifact which uses a versioned artifact
            - The artifact is linked to the build and gives us automatic traceability
            and it gives us automatic traceability
            - The build pipeline compiles, tests and eventually produces an 
            immutable package stored in a secured place (storage, database, etc)
            - The release pipeline then uses a secure connection to this secured
            place to get the build artifact and do extra actions to deploy it to
            an environment
            - Another common artifact source is version control  (VC) where the 
            releases is related to a specific commit in our version control system
            - VC makes more sense if you want to deploy one specific file and you 
            don't need to run more actions before using this file in your release
            pipeline
            - With the VC, we can also see which version of a file or script is
            eventually installed, where in the version does not come from the 
            build but version control
            - Another possibility of an artifact source is a network share containing
            a set of files but it is risk prone as other people may have access to 
            the network share where the package was put
            - Container Registries are upcoming regarding artifact sources which
            stores container artifacts
            - A proper mechanism to make sure you can provide the correct 
            traceability and auditability is using immutable packages by versioning
            those packages
            - Using a build pipeline that produces a package stored in a location
            that humans can't access, you ansure the sources are unchanged throughout
            the whole release-process and this is an essential concept of release
            pipelines

        - Trigger:
            - Manual Trigger 
            - Schedueled Trigger (Cron)
            - Continous Deployment Trigger, where another event triggers a release,
            ex. a completed build
        - Stages:
            - This is where the artifacts will be eventually installed
            - You may have many stages and part of the release strategy is finding the
            appropriate combination of stages
            - Trigger of a particular stage can happen in three ways:
                - After Release:
                    - Stage which immediately follows a release
                - After Stage:
                    - Completion of another stage
                - Manual Only:
                    - Requires Manual Triggering
                - The name stages is a better fit than environment even though
                the stages can be used for environments
        - Approval:
            - People often sign a release before installing it in the environment
            - The manual process can be replaced by an automatic process that checks
            the quality before the components move on to the next stage
        - Tasks:
            - Steps that need to be executed to install, configure and validate the 
            installed artifact
        - Jobs:
            - A release job is executed by a build/release agent. This agent can
            only run one job at the same time 
            - You specify a series of tasks you want to run on the same agent during
            your job design
            - The release pipelines brings the artifacts togather and wants to deploy
            the backend, frontend, and mobile app all together as part of one release
            - The deployment takes place on different agents
            - By default, jobs run on the host machine where the agent is installed

    - When designing your release strategy, chose your triggers carefully and 
    consider the required release cadence

Explore Release Recommendations:
    - There are three types of triggers:
        - Continous Deployment Trigger:
            - Set up this trigger on your release pipeline
            - Post the setup, your release pipeline will trigger every time a build
            completes and creates a new release
        - Scheduled Triggers:
            - Allows you to set-up a time based manner to start a new release
            - You can have one or multiple daily schedules, but it will always run 
            at this specific time
        - Manual Trigger:
            - A person or system triggers the release band on a specific event
            - When it's a person, it probably uses some UI to start a new release
            - When it's an automated process, some events will likely occur
    
    - When we refer to deployment, we refer to each stage, where each stage can have its
    triggers that determine when the deployment occurs
    - With the imposition of pre-deployment conditions, deployment to any stage doesn't
    happen automatically unless you have chosen to allow that
    - Manual Approvals Approvals:
        - It suits a significant need
        - Organizations that starts with continous delivery, often lacks a certain
        amount of trust and they don't dare to release without manual approval
        - After sometime, they find out that the approval does not add value and the
        release always succeeds
        - The manual approval is then replaced by an automatic check
    
    - Release Gates:
        - They gives you more control over the start and completion of the deployment
        pipeline
        - They are often set up as pre-deployment and post-deployment conditions
        - It's a planning session where the release schedule of dependent components
        is discussed
        - By using scripts and APIs, you can create your release gates instead of manual
        aproval, or atleast extend your manual approval
        - When the release starts, it checks the state of the gate by calling an API
        - If the "gate" is open, we can continue; otherwise we'll stop the release
        - Approvals and gates enables you to control and start and completion of the
        deployments in a release
        - Using Release Gates, you can specify application health criteria to be met 
         before the release is promoted to the following environment
         - Multiple gates can be added to the environment conditions to ensure all the
         inputs are successful for the release
         - Pre-deployment gates ensure no active issues in the work item or problem 
         management system before deploying a build to an environment
         - Post-deployment gates ensure no incident from the app's monitoring or incident
         management system after being deployed before promoting the release to the 
         following environment 
        - Scenarios where release gates may be required:
            - Incident and issue management
            - Notify users such as legal approval departments, auditors or IT managers
            about a deployment by integrating with approval collaboration systems like
            Teams or slack, waiting for the approval to completed
            - Quality Validation
            - Security scan on artifacts
            - User experience relative to baseline
            - Change Management
            - Infrastructure Health
        - There are four different release gates:
            - Invoke Azure Function:
                - Trigger to ensure a successful completion
            - Query Azure Monitor Alerts:
                - Observe the configured Azure Monitor alert rules for active Alerts
            - Invoke REST API:
                - Make a call to a REST API and continue if it returns a successful
                response
            - Query Work Items:
                - Ensure the number of matching work items returned from a query is 
                within a threshold
        - Quality Gate:
            - It is the best way to enforce a quality policy in your 
            organization, which is there to answer one question: Can I deliver my 
            application to production or not?
            - It is located before a stage that is dependent on the outcome of a previous
            stage.
            - It is something that a QA department monitored in the past who used 
            guidelines, policies and checks to verify if a software was of a good 
            quality to move on to the next stage
            - Quality gates automate these checks as part of our release pipeline
            - Ex. of quality gates:
                - No Blocker Issues
                - Code coverage on new code greater than 80%
                - No licence violations
                - No vulnerabilities in dependencies
                - No further technical debt was introduced
                - Compliance checks:
                    - Are there work items linked to the release
                    - Is the release started by someone else as the one who commits the 
                    code 
    
Provision and Test Environments:
    - When a release pipeline deploys software to a target environment, it 
    is only not the software that will be deployed with the release pipeline
    - Infrastructure as Code and Spinning up Infrastructure as part of your 
    release pipeline is essential as well
    - When we focus on the deplloyment of the Infrastructure, we should first
    consider the differences between the target environments that we can deploy to:
        - On Premise Servers:
            - When you deploy to an on-premise server, the hardware and OS are 
            already in place; the server is already there and ready
            - Hence the release pipeline can only focus on deploying the app
            - You might want to start or stop your server with a Hyper-V or VMware
            - Using a task in the release pipeline, you can run the script that
            starts or stops the servers
            - To take one step further and configure the servers, you should look
            at technologies like Powershell desired State Configuration (DSC)
            - The product maintains your server and keep in in a particular state
            and when the server changes its state, you can recover the changed
            configurations to the original configuration
        - Cloud Servers or IAAS (Ex. VMs):
            - Creating a script or template can make a server or other 
            infrastructural components like a SQL server, a network, or an IP address
            - By defining a template or using a command line and saving it in a
            script file, you can use that file in your release pipeline to execute
            it on your target cloud 
            - The server will be created as part of your pipeline, post which you
            can run the steps to deploy the software
            - Technologies like ARM are great for creating Infrastructure on Demand
        - PaaS and Functions as a Service:
            - In PaaS, you will get the infrastructure from the cloud you are
            running on
            - The cloud arranges the server, the hardware, the network, the public 
            IP address, the storage account and even the web browser
            - The user only needs to take care of the application on this platform
            - You only instruct the platform to create a placeholder where your
            application can be hosted
            - You can define this template in ARM by using Azure CLI or Command line 
            tools
            - The infrastructure is defined in a script file and lives alongside
            the application code in source control
        - Clusters:
            - It is a group of software that will be deployed with the release 
            pipeline
            - While focussing on Continous delivery, IaaC and spinning up infra
            as part of your release pipeline is essential
            - While runnning IaaS cluster, you must create and maintain the cluster
            - It means that you need to provide the templates to create a cluster
            - Also you must ensure that you roll out updates, bug fixes, and patches
            to your cluster
            - While running a hosted clusted (PaaS), you instruct the cloud to create 
            the cluster and you deploy your software to the cluster
            - When running container clusters, you can use cluster technologies like 
            AKS
        - Service Connections
            - They are created when a pipeline needs resource access (ex. Github)
            - Revisit the "Exercise - set up service connections"
    - Few Principles of testing includes:
        - Tests should be written at the lowest level possible
        - Write once, and run anywhere, including the production system
        - The product is designed for testability
        - Test Code is product code; only reliable tests survive
        - Test ownership follows product ownership
    - The build and release agent can handle executing Unit Tests or other low-level
    tests that don't need a deployed application or infrastructure
    - When you need to do tests with a UI or other specialized functionality, you 
    need a Test agent to run the test and report the results
    - Installation of the agent then needs to be done upfront or as part of the 
    execution of your pipeline
    - The goal for "shifting left" is to move quality upstream by performing tests
    early in the pipeline
    - It represents the phrase "fail fast, fail often" combining test and process
    improvements reducing the time it takes for tests to be run and the impact of 
    failures later on
    - The idea is to ensure that most of the testing is complete before merging a 
    change into the main branch
    - Unit tests needs to be fast and reliable while functional tests must be
    independent
    - Availabilty Tests:
        - After you have deployed your web app or website to any server, you can 
        set up tests to monitor its availability and responsiveness
        - Some applications have specific health endpoints that an automated process
        can check
        - The health endpoint can be an HTTPS status or a complex computation that
        uses and consumes crucial parts of your application
        - You can use availability tests (ping tests) in your pipeline and as release
        gates
        - In Azure you can set up availability tests for any HTTP or HTTPS endpoint
        accessible from the public internet
        - Two types of Availability Tests:
            - URL ping test:
                - Simple test that can be created in the Azure Portal
                - Check the URL and check the response and status code of the response
            - Multi-step web test:
                - Several HTTP calls that are executed in sequence
    - Azure Load Testing:
        - It is a fully managed load-testing service that enables you to generate
        a high scale load
        - The service simulates your applications' traffic, helping you optimize
        application performance, scalability or capacity
        - Create a load test using existing test scripts based on Apache JMeter
        - It abstracts the infrastructure to run your JMeter script and load test
        your application
        - It collects detailed resource metrics for Azure-based applications to help
        you identify performance bottlenecks across your Azure application components
        - Use Azure Load testing as part of CI/CD workflow
        - Azure Load Testing uses Azure Monitor to capture metrics for app components
        - Automatically run a load test at the end of each sprint or in a staging 
        environment to validate a release candidate build
        - Trigger Azure Load Testing from Azure Pipelines or Github Actions Workflow
    