Introduction to Deployment Patterns:
    - Azure Pipelines can be used to create a fully featured cross-platform CI and 
    CD service
    - Microservices Architecture:
        - Interaction between the microservices is done asynchronously
        - They don't call each other directly, but use asynchronous mechanisms like
        queues or events
    - In classical deployment patterns, despite the different stages to test and
    validate, this approach still involves a lot of risks

Implement blue-green deployment and feature toggles:
    - Blue Green Deployment:
        - It is a technique that reduces risk and downtime by running two identical 
        environments which are called blue and green
        - Only one of the environments is live, with the live environment serving 
        all production traffic
        - Initially blue is live and green is idle
        - As you prepare a new version of your software, the deployment and final 
        testing stage occur in an environment that isn't live
        - Once you have deployed and thoroughly tested the software in green, 
        switch the router or load balancer so all incoming requests go to green
        instead of blue
        - Green is now live and blue is idle
        - This technique can eliminate downtime because of app deployment
        - It reduces risk since if something unexpected happens with your new version
        on the green, you can immediately roll back to the last version by switching
        back to blue
        - When it involves database schema changes, your application and architecture
        should be built to handle both the old and the new database schema
    - Explore Deployment Slots:
        - When using Azure, doing blue-green deployments is relatively easy
        - You don't have to write your code or set up infrastructure
        - Use an out-of-the box feature called deployment slots when using web apps
        - They are a feature of Azure App Service and are live apps with hostnames
        - You can create different slots for your application (ex. dev, stage, test)
        - Production slot is the slot where your live app stays
        - Validate app changes in staging with deployment slots before swapping them
        with your production slot
        - You can use a deployment slot to set up a new version of your application 
        and when ready, swap the production environment with the new staging environment
        - The above is done by an internal swapping of the IP addresses of both slots
        - The swap eliminates downtime when you deploy your app with seamless traffic 
        redirection, and no requests are dropped because of swap operations
    
    - Introduction to Feature Toggles / Feature Flags:
        - It allows you to change how our system works without making significant 
        changes to the code
        - Only a small configuration change is required and in many cases, it will
        also only be for a few users
        - The other type of feature flag is called the release flag, wherein you change 
        the configuration so that canary users also have the feature flag set, and 
        they will start to test the new code as well. If any problem occurs, you can
        quickly disable the flag for them again
        - Another release flag might be used for AB testing where you would want to 
        find out if a new feature makes it faster for users to complete a task
        - You can then directly compare the outcome and decide if the feature is worth
        keeping 
        - Feature Toggles are great alternative to branching as well where you build
        new features behind a toggle
        - You feature is off when a release occurs and should not be exposed to or
        impact the production software
        - Feature Flag should not be repurposed as reusing old flag leads to failures
        and increases technical debt
        - A plan for managing the lifecycle of feature flags is critical and as soon
        as you add a flag, you need to plan for when it will be removed

Implement Canary Releases and Dark Launching:
    - A canary release is a way to identify potential problems without exposing all your
    end users to the issue at once
    - By closely monitoring what happens when you enable the feature, you can get 
    relevant information from this set of users and either continue or rollback 
    (disable the feature)
    - If the canary release shows potential performance or scalability problems, you
    can build a fix for that and apply that in the canary environment
    - After the canary release has proven to be stable, you can move the canary release
    to the actual production environment
    - It can be implemented using a combination of feature toggles, traffic routing,
    and deployment slots
    - You can route a percentage of traffic to a deployment slot with the new feature
    enabled
    - You can target a specific user segment by using feature toggles
    - Examine TraffiC Manager:
        - If you want more control over the traffic that flows to your versions, 
        deployment slots aren't enough, which only enables you to swap between two
        different versions of your application quickly
        - To control traffic in Azure, you can use a component called Azure Traffic 
        Manager
        - Azure Traffic Manager is a DNS based traffic load balancer that enables you
        to distribute traffic optimally to services across global Azure regions 
        while providing high availability and responsiveness
        - It uses DNS to direct client requests to the most appropriate service endpoint
        based on a traffic-routing method and the health of the endpoints
        - Traffic Manager is resilient to failure, including the breakdown of an entire
        Azure region
    - Traffic Manager currently provides six options to distribute traffic:
        - Priority:
            - When you use a primary service endpoint for all traffic and provide 
            backups if the primary or the backup endpoints are available
        - Weighted:
            - Most used
            - When you want to distribute traffic across a set of endpoints, either 
            evenly or according to weights, which you define
        - Performance:
            - When you have endpoints in different geographic locations, and you want
            end users to use the closest endpoint for the lowest network latency
        - Geographic:
            - When users are directed to specific endpoints based on which geographic
            location their DNS query originates from
            - Ex. Where it is mandatory to follow data sovereignty, localization of
            content and user experience and measuring traffic from different regions
        - MultiValue:
            - When users only have IPv4/IPv6 addresses as endpoints
            - When a query is received for this profile, all healthy endpoints are 
            returned
        - Subnet:
            - Maps sets of end-user IP addresses to a specific endpoint within a traffic
            manager profile
            - The endpoint returned will be mapped for that request's source IP address
            when a request is received
    - Using a combination of feature toggles, deployment slots, and traffic manager, you
    can achieve complete control over the traffic flow and enable your canary release
    - Dark Launching:   
        - Dark launching is like canary releases
        - The difference here's that you'r looking to assess users' response to new
        features in your frontend rather than testing the performance of the backend
        - The idea is rather than launch a new feature for all users, you instead release
        it to small set of users
        - Usually these users are not aware they are being used as test users for the 
        new feature and often you don't even highlight the new feature to them, as 
        such as the term "Dark Launching"
        - Another ex. of dark launching is launching a new feature and using it on the
        backend to get metrics which SpaceX does 

Implement A/B Testing and Progressive exposure deployment:
    - A/B Testing:
        - A/B testing (also known as split testing or bucket testing) compares two 
        versions of an app against each other to determine which one does better
        - It is mainly an experiment where two or more page variants are shown
        to users at random
        - Statistical analysis is used to determine which variation works better
        for a given conversion goal
    - Progressive Exposure Deployment:
        - Progressive exposure deployment, also called ring-based deployment supports 
        the production-first devops mindset and limit the impact on end users while
        gradually deploying and validating changes in production
        - Impact (also called Blast Radius) is evaluated through observation, testing,
        analysis of telemetry and user feedback
        - In devops, rings are typically modelled as stages
        - With a ring based deployment, you first deploy your changes to risk-tolerant
        customers and progressively roll out to a more extensive set of customers
        - Some organizations that use canary releasing have muliple deployment slots
        set up as rings
        - The first release of the feature to ring 0 targets a well-known set of users,
        mostly their internal organization
        - After things have been proven stable in ring 0, they propagate the release to
        the next ring. It's with a limited set of users outside their organization
        - Finally the feature is released to everyone, and is often done by flipping the
        switch on the feature toggles in the software
        - Monitoring and health checks are essential, and by using post deployment
        release gates that check a ring for health, you can define an automatic
        propagation to the next ring after everything is stable
        - When a ring is not healthy, you can halt the deployment to the following rings
        to reduce the impact

Integrate with Identity Management Systems:
    - Integrate GitHub with single sign-on:
        - For Integration of Github with Single sign-on (SSO), you need to connect your
        identity provider at the organization level
        - Github offers both SAML and SCIM support
    - Explore Service Principals:
        - To access resources, an entity must be represented by a security principal
        - To connect, the entity must know:
            - TenantID
            - ApplicationID
            - ClientSecret
        - Applications are registered with a Microsoft Entra tenant within Microsoft
        Entra ID
        - Registering an application creates an identity configuration and determine
        who can use it:
            - Accounts in the same organizational directory
            - Accounts in any organizational directory
            - Accounts in any organizational directory and Personal Microsoft Accounts
            - Personal Microsoft Accounts
        - Once the application is created, you then should create at least one client
        secret for the application
        - The application identity can then be granted permssions within services 
        and resources that trust Microsoft Entra ID
    - Explore Managed Identity:
        - Many Azure Services expose their own identity 
        - It isn't an identity that you need to manage
        - Ex. you don't need to worry about password policies and so on
        - You can assign permissions to that identity as with any other Microsoft 
        Entra Identity
        - There are two types of Managed Identities:
            - System-assigned
            - User-assigned: 
                - You create a managed identity as an Azure Resource
                - It can then be assigned to one or more instances of a service