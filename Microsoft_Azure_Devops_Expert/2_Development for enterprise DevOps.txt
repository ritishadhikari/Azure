Structure your Git Repo:
    - A repository is where your work history is stored, usually in a git
    repository
    - Monorepos:
        - It'a s source control pattern where all source code is kept in 
        one repository
        - Give all employees access to everything at once
        - The hassle of making changes in other repos or waiting for teams to make 
        changes for you is avoided in a mono repo where anyone can change anything
        - Managing complex dependency graphs can increase the difficulty of using a 
        single repository
    - Multiple Repositories:
        - Organizing your project into multiple repositories
        - It allows each subteam to work in their respective areas using the libraries,
        tools, and development workflows that optimize their productivity
        - In Azure Devops, it's common to use a separate repository for each associated
        solution within a project
    - The fundamental difference between the monorepo and multiple repos philosophies
    boils down to a difference about what will allow teams working togather on a system
    to go faster
    - Preference is always to avoid dumping log entries into a changelog. 
        # git log [options] vxx | helper-script>projectchangelogs/x.x.Y
    - With logging, the typical breakdown is to separate a list of versions and then
    within each version show:
        - Added Features
        - Modified/Improved Features
        - Deleted Features
    - One common tool to create a changelog is gitchangelog, which is based on python

    Manage Git branches and workflows:
        - Trunk Based Development:
            - It is a logical extension of centralized workflow
            - The core idea is that all feature development should take place 
            in a dedicated branch instead of a main branch
            - This encapsulation makes it easy for multiple developers to work 
            on a particular feature without disturbing the main codebase
            - It should also mean that the main branch should never contain 
            broken code, which then becomes a huge advantage for Continous
            integration environments.
        - Forking Workflow:
            - Instead of using a single server-side repository to act as the 
            "central" codebase, it gives every developer a server-side repository
            - Each contributor has two Git Repositories:
                - A private local one
                - A public server-side one

        - Pull Requests:  
            - Pull requests make it incredibly easy for your team to comment on each 
            other's work 
            - It allows sharing a feature with other developers without touching
            any official code
            - Create a pull request during the development process when:
                - You have little or no code but want to share screenshots or 
                general ideas
                - You are stuck and need some help or advice
                - You are ready for someone to review your work
                - If you are using a Fork and Pull Model, pull requests provide a 
                way to notify project maintainers about the changes you would like
                them to consider
                - If you are using a shared repository model, Pull requests help 
                start code review and conversion about proposed changes before they 
                are merged into the main branch
                - Once a pull request is merged with a main and feature, Pull request
                preserves a record of the historical changes to your code.
                - Because the historical information is searchable, they let anyone go
                back in time to understand why and how a decision was made
            
        
        - Feature branches should have descriptive names which gives a clear,
        highly focussed purpose

        - Anything on the main branch is always deployable
        - Each commit is considered a separate unit of change, which lets you 
        roll back changes if a bug is found or you decide to head in a different 
        direction
    
    - The Main Branch:
        - Any changes to the main branch flow through pull requests only
        - Tag all releases in the main branch with Git tags
    
    - The Feature Branch:
        - Changes from feature branches to the main only flow through pull requests
        - Name your feature to reflect its purpose

    - Azure CLI:
        - Command Line Interface for Azure
    - Azure Devops CLI:
        - Extension of Azure CLI for working with Azure Devops and Azure Devops Server
        designed to seamlessly integrate with Git, CI Pipelines and Agile tools
        - Contribute to your projects without leaving the command line
        - Works on Windows, Linux and Mac
        - Supports returning the query results in JSON, JSONC, YAML, YAMLC, table, TSV
        and None
    - Git Pull Request Merge Conflict:
        - Open source extension created by Azure Devops
        - Allows you to review and resolve the pull request merge conflicts on the web
        - Any conflicts with the target branch must be resolved before a Git Pull 
        request can complete
        - Resolve conflicts on the web as part of the pull request merge instead of
        doing the merge and resolving conflicts in a local clone
    
    - Pull request using the Azure Devops CLI:
        """
            az repos pr create --title "Review Feature-1 before merging to main"
            --work-items 38 39 --description "#Merge feature-1 to main"
            --source-branch feature/MyFeture-1 --target-branch main
            --repository myWebApp --open
        """ 
        - --open means open it in a web browser after it has been created
        - --deletesource-branch means delete the branch after the pull request is 
        complete
        - --auto-complete means complete automatically when all policies have passed
        and the source branch can be merged into the target branch
    
    - A Lean branching Model allows you to create short-lived branches and push quality 
    changes to production faster

    - Github Flow:
        - It is a branch based workflow suggested for Github
        - There are other Pull requests configurations, such as automatically requesting
        a review from specific teams or users when a pull request is created or checks
        to run on pull requests
    
    - Explore Fork Workflow:
        - Instead of using a single server-side repository to act as the central 
        codebase, it gives every developer their server-side repository
        - This kind of workflow is most often seen in public open-source project
        - Developers push to their server side repositories and only the project
        maintainer can push to the official repository
        - It allows the maintainer to accept commits from any developer without
        giving them written access to the official codebase
        - Forked repositories are generally server-side clones managed by a git service
        provider such as Azure Repos
        - There's no unique Git Command to create forked repositories

    - We can set up branch policies to restrict direct commit into a particular branch
    and it encourages pull requests
    - Linking a Work Item with a Pull request:
        - Set up branch policies. and enable link work linking option
        - Create a Work Item as to do
        - Once commit happens in a feature branch, create a pull request
        - In the warning message that comes next, in the link work item section,
        link the work item that was created
        - Once the pull request is merges with the main branch, the work item moves
        to the done state.